{"ast":null,"code":"import { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\nlet handoffFrameTime;\nfunction handoffOptimizedAppearAnimation(elementId, valueName,\n/**\r\n * Legacy arguments. This function is inlined as part of SSG so it can be there's\r\n * a version mismatch between the main included Motion and the inlined script.\r\n *\r\n * Remove in early 2024.\r\n */\n_value, frame) {\n  const optimisedValueName = transformProps.has(valueName) ? \"transform\" : valueName;\n  const storeId = appearStoreId(elementId, optimisedValueName);\n  const optimisedAnimation = appearAnimationStore.get(storeId);\n  if (!optimisedAnimation) {\n    return null;\n  }\n  const {\n    animation,\n    startTime\n  } = optimisedAnimation;\n  const cancelAnimation = () => {\n    appearAnimationStore.delete(storeId);\n    if (frame) {\n      /**\r\n       * If we've been provided the frameloop as an argument, use it to defer\r\n       * cancellation until keyframes of the subsequent animation have been resolved.\r\n       * This \"papers over\" a gap where the JS animations haven't rendered with\r\n       * the latest time after a potential heavy blocking workload.\r\n       * Otherwise cancel immediately.\r\n       *\r\n       * This is an optional dependency to deal with the fact that this inline\r\n       * script and the library can be version sharded, and there have been\r\n       * times when this isn't provided as an argument.\r\n       */\n      frame.render(() => frame.render(() => {\n        try {\n          animation.cancel();\n        } catch (error) {}\n      }));\n    } else {\n      try {\n        animation.cancel();\n      } catch (error) {}\n    }\n  };\n  /**\r\n   * If the startTime is null, this animation is the Paint Ready detection animation\r\n   * and we can cancel it immediately without handoff.\r\n   *\r\n   * Or if we've already handed off the animation then we're now interrupting it.\r\n   * In which case we need to cancel it.\r\n   */\n  if (startTime === null || window.HandoffComplete) {\n    cancelAnimation();\n    return null;\n  } else {\n    /**\r\n     * Otherwise we're handing off this animation to the main thread.\r\n     *\r\n     * Record the time of the first handoff. We call performance.now() once\r\n     * here and once in startOptimisedAnimation to ensure we're getting\r\n     * close to a frame-locked time. This keeps all animations in sync.\r\n     */\n    if (handoffFrameTime === undefined) {\n      handoffFrameTime = performance.now();\n    }\n    /**\r\n     * We use main thread timings vs those returned by Animation.currentTime as it\r\n     * can be the case, particularly in Firefox, that currentTime doesn't return\r\n     * an updated value for several frames, even as the animation plays smoothly via\r\n     * the GPU.\r\n     */\n    return handoffFrameTime - startTime || 0;\n  }\n}\nexport { handoffOptimizedAppearAnimation };","map":{"version":3,"names":["transformProps","appearAnimationStore","appearStoreId","handoffFrameTime","handoffOptimizedAppearAnimation","elementId","valueName","_value","frame","optimisedValueName","has","storeId","optimisedAnimation","get","animation","startTime","cancelAnimation","delete","render","cancel","error","window","HandoffComplete","undefined","performance","now"],"sources":["C:/Users/LENOVO/OneDrive/Desktop/SAP/frontend/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs"],"sourcesContent":["import { transformProps } from '../../render/html/utils/transform.mjs';\r\nimport { appearAnimationStore } from './store.mjs';\r\nimport { appearStoreId } from './store-id.mjs';\r\n\r\nlet handoffFrameTime;\r\nfunction handoffOptimizedAppearAnimation(elementId, valueName, \r\n/**\r\n * Legacy arguments. This function is inlined as part of SSG so it can be there's\r\n * a version mismatch between the main included Motion and the inlined script.\r\n *\r\n * Remove in early 2024.\r\n */\r\n_value, frame) {\r\n    const optimisedValueName = transformProps.has(valueName)\r\n        ? \"transform\"\r\n        : valueName;\r\n    const storeId = appearStoreId(elementId, optimisedValueName);\r\n    const optimisedAnimation = appearAnimationStore.get(storeId);\r\n    if (!optimisedAnimation) {\r\n        return null;\r\n    }\r\n    const { animation, startTime } = optimisedAnimation;\r\n    const cancelAnimation = () => {\r\n        appearAnimationStore.delete(storeId);\r\n        if (frame) {\r\n            /**\r\n             * If we've been provided the frameloop as an argument, use it to defer\r\n             * cancellation until keyframes of the subsequent animation have been resolved.\r\n             * This \"papers over\" a gap where the JS animations haven't rendered with\r\n             * the latest time after a potential heavy blocking workload.\r\n             * Otherwise cancel immediately.\r\n             *\r\n             * This is an optional dependency to deal with the fact that this inline\r\n             * script and the library can be version sharded, and there have been\r\n             * times when this isn't provided as an argument.\r\n             */\r\n            frame.render(() => frame.render(() => {\r\n                try {\r\n                    animation.cancel();\r\n                }\r\n                catch (error) { }\r\n            }));\r\n        }\r\n        else {\r\n            try {\r\n                animation.cancel();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    };\r\n    /**\r\n     * If the startTime is null, this animation is the Paint Ready detection animation\r\n     * and we can cancel it immediately without handoff.\r\n     *\r\n     * Or if we've already handed off the animation then we're now interrupting it.\r\n     * In which case we need to cancel it.\r\n     */\r\n    if (startTime === null || window.HandoffComplete) {\r\n        cancelAnimation();\r\n        return null;\r\n    }\r\n    else {\r\n        /**\r\n         * Otherwise we're handing off this animation to the main thread.\r\n         *\r\n         * Record the time of the first handoff. We call performance.now() once\r\n         * here and once in startOptimisedAnimation to ensure we're getting\r\n         * close to a frame-locked time. This keeps all animations in sync.\r\n         */\r\n        if (handoffFrameTime === undefined) {\r\n            handoffFrameTime = performance.now();\r\n        }\r\n        /**\r\n         * We use main thread timings vs those returned by Animation.currentTime as it\r\n         * can be the case, particularly in Firefox, that currentTime doesn't return\r\n         * an updated value for several frames, even as the animation plays smoothly via\r\n         * the GPU.\r\n         */\r\n        return handoffFrameTime - startTime || 0;\r\n    }\r\n}\r\n\r\nexport { handoffOptimizedAppearAnimation };\r\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,uCAAuC;AACtE,SAASC,oBAAoB,QAAQ,aAAa;AAClD,SAASC,aAAa,QAAQ,gBAAgB;AAE9C,IAAIC,gBAAgB;AACpB,SAASC,+BAA+BA,CAACC,SAAS,EAAEC,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACAC,MAAM,EAAEC,KAAK,EAAE;EACX,MAAMC,kBAAkB,GAAGT,cAAc,CAACU,GAAG,CAACJ,SAAS,CAAC,GAClD,WAAW,GACXA,SAAS;EACf,MAAMK,OAAO,GAAGT,aAAa,CAACG,SAAS,EAAEI,kBAAkB,CAAC;EAC5D,MAAMG,kBAAkB,GAAGX,oBAAoB,CAACY,GAAG,CAACF,OAAO,CAAC;EAC5D,IAAI,CAACC,kBAAkB,EAAE;IACrB,OAAO,IAAI;EACf;EACA,MAAM;IAAEE,SAAS;IAAEC;EAAU,CAAC,GAAGH,kBAAkB;EACnD,MAAMI,eAAe,GAAGA,CAAA,KAAM;IAC1Bf,oBAAoB,CAACgB,MAAM,CAACN,OAAO,CAAC;IACpC,IAAIH,KAAK,EAAE;MACP;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACYA,KAAK,CAACU,MAAM,CAAC,MAAMV,KAAK,CAACU,MAAM,CAAC,MAAM;QAClC,IAAI;UACAJ,SAAS,CAACK,MAAM,CAAC,CAAC;QACtB,CAAC,CACD,OAAOC,KAAK,EAAE,CAAE;MACpB,CAAC,CAAC,CAAC;IACP,CAAC,MACI;MACD,IAAI;QACAN,SAAS,CAACK,MAAM,CAAC,CAAC;MACtB,CAAC,CACD,OAAOC,KAAK,EAAE,CAAE;IACpB;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIL,SAAS,KAAK,IAAI,IAAIM,MAAM,CAACC,eAAe,EAAE;IAC9CN,eAAe,CAAC,CAAC;IACjB,OAAO,IAAI;EACf,CAAC,MACI;IACD;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAIb,gBAAgB,KAAKoB,SAAS,EAAE;MAChCpB,gBAAgB,GAAGqB,WAAW,CAACC,GAAG,CAAC,CAAC;IACxC;IACA;AACR;AACA;AACA;AACA;AACA;IACQ,OAAOtB,gBAAgB,GAAGY,SAAS,IAAI,CAAC;EAC5C;AACJ;AAEA,SAASX,+BAA+B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}